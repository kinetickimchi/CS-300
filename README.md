# CS-300 Module 8 Journal

# What was the problem you were solving in the projects for this course?
The projects in this course were focused on applying provided data sets into appropriate data structures (such as vectors, linked lists, and hash tables) and then manipulating those data structures to achieve a desired output.

# How did you approach the problem? Consider why data structures are important to understand.
My approach to each project began with thoroughly analyzing the data set, which is necessary in order to decide which type of data structure would be best for each data set. For smaller, less complex data sets, a vector would be fine to use, while a data set that involved lots of insertion or deletion operations may be better suited to a linked list format.

# How did you overcome any roadblocks you encountered while going through the activities or project?
Most important was having a strong understanding of the data structures we were using. After we were first introduced to linked lists, I found I was having difficulty understanding fully how pointers worked. By looking at other examples of linked lists such as on YouTube or Stack Overflow, having pointers explained in different ways made the concepts easier to grasp.

# How has your work on this project expanded your approach to designing software and developing programs?
My biggest takeaway from these projects has been learning to seriously consider efficiency when developing my programs. When programming a function, the first way that comes to mind may not be the most efficient way to get a task done, and this would only multiply as applications grew more complex. Performing the runtime analysis gave me a way to easily visualize the difference in efficiency when considering different data structures.

# How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?
A major skill I learned working on the projects in this class was more practice making my code as modular as possible. The assignments were designed in a way that we were trying to achieve a similar end goal, but using different methods and data structures each time. By recognizing when a function was similar to something I had already coded in a previous assignment, I was able to practice refactoring my code in a way that allows it to be pulled out of one project and easily inserted into another, saving me time in the end.
